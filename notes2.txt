BVH - Bounding Volume Hierarchies
Perlin Texture 
Motion Blur - brute forced (речиси сите ефекти се постигнуваат така), camera shoter reporodcution
Ray + time variable - za eden frame ni e potreben interval [0,1]
Sphere - se dvizi od center1 do center2 vo interval [0,1]
Scatter - move in a random dirrection

Bounding Volume Hierarchies:
	hittable refactoring
	ray-object intersection - bottleneck
	logarithmic search instead of binary search
	Podreuvanje na objektite vo scena:
		1) subdivide the space
		2) subdivide the objects
	Bounding sphere (gi sodrzi site objekti), ako zrakot ne ja pokoti --> ne pogodil ni eden objekt
	Gorup the objects in subgroubs
	Axis-Aligned Bounding Boxes (AABBs) - polesna podelba na prostorot na podgrupi
	proveruvame dali ima interferencija so x0, y0, z0 oskite
	aabb - bounding box
BVH Node Class - kontejner za hittable objekti
	najbitno - pravilno da se podelat objektite vo podgrupite
	Podelba:
		1.randomly choose an axis
		2.sort the primitives (using std::sort)
		3.put half in each subtree
	
Texture mapping:
	texture - effect (color, shininess, bump geometry)
	mapping - mathematical part
	(u,v) coordinates

	solid texture - colors all of the pixels in a given space
	spatial texture - 

	Sphericla coords:
		(θ,ϕ) -  θ - the angle up from the bottom pole (that is, up from -Y)
		ϕ - the angle around the Y-axis (from -X to +Z to +X to -Z back to -X).
		u=ϕ/2π
		v=θ/π
	Texture Image Data:
		image data -> 32-bit floats
	
Perlin Noise
	- repeatable 
	- smoothening
	- Vector instead of floats - dot product, za da nema ekstremi (min and max)
	- Turbulance -  sum of repeated calls to noise
	- Sin(x)  - to make color more proportional in the turbulence	--> Marbel effect
Quadrilaterals
	- Paralelogram
	Q1 - starting corner
	u - vector, the first side, Q+u - adjacent corner
	v - vector, the second side, Q+v - other adjacent corner
	Q+u+v - opposite corner
	Ex. Q=(0,0,0), u=(0,0,2), v=(0,1,0), 
	Quads - flat - 0 thicknes -> numeric proble,s with ray intersection - SOLUTION - aabb always to have non zero
	t = (D-n*P)/n*d - Point of intersection with the ray
Lights
	key component of ray tracing
Transformations
	instance - copy of a geometric primitive - hittable box
	trainslating the box - "+" opperator in interval/aabb classes
	Translation intersections:
		1.Move the ray backwards by the offset
		2.Determine whether an intersection exists along the offset ray (and if so, where)
		3.Move the intersection point forwards by the offset
	Rotations - x,y,z - axis
	Around z-axis:		//za x, x->z, za y, y->z
		x′=cos(θ)⋅x−sin(θ)⋅y
		y′=sin(θ)⋅x+cos(θ)⋅y