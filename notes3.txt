Radnomized algorithms:
	Monte Carlo
	Las Vegas
Monte Carlo - correct result and frequently gets it wrong
Las Vegas - always correct

Las Vegas - multiple interations, always gets to correct
Monte Carlo - fixed num of iterations, good estimation

Pi estimation:
	πr^2/(2r)^2=π/4

Ray tracing - two new dimensions: ϕo & θo

Stratification - sharper contrast at the edges of a plane (better effect on textures and reflective materials)

One dimensional Monte Carlo

One Dimensional Monte Carlo Integration
	area(circle)/area(square) = π/4
	circumscribed square is 4r2	-> area(circle)=πr2
	r = 1 -> areac(circle)= π
	
	1. X=(x0,x1,...,xN−1)
	2. yi=f(xi)
	3. Y=F(X)
	4. Y=(y0,y1,...,yN−1)=(f(x0),f(x1),...,f(xN−1))
	5. verage(Yi)=E[Y]=1N∑i=0N−1yi = 1N∑i=0N−1f(xi) = E[F(X)]
	E[Y]	- Expected value of Y

	E[f(x′)|a≤x′≤b]=limN→∞1N∑i=0N−1f(xi)	- Monte Carlo Algorithm - summing an infinite number of randim points
	Sampling Random Points:
		xi=a+iΔx
		Δx=b−aN
		E[f(x′)|a≤x′≤b]≈1N∑i=0N−1f(xi)∣∣xi=a+iΔx
		E[f(x′)|a≤x′≤b]=limN→∞1b−a∑i=0N−1f(xi)Δx∣∣xi=a+iΔx
		E[f(x′)|a≤x′≤b]=1b−a∫baf(x)dx
		area(f(x),a,b)=∫baf(x)dx
		E[f(x)|a≤x≤b]=1b−a⋅area(f(x),a,b)
	
	Solving Integral with Monte Carlo:
		I=area(x2,0,2) or E[f(x)|a≤x≤b]=1b−a⋅area(f(x),a,b) -> I=2⋅average(x2,0,2)
	
	Density Functions
		ray_color - problem - Small light sources create too much noise, Light sources are only sampled if a ray scatters toward them
		density function - continuous version of a histogram
		discrete density function - normalizes the y-axis to a fraction or percentage of the total:
			Density of Bin i = Number of items in Bin i / Number of items total
			discrete -> density : Bin Density = (Fraction of trees between height H and H′) / (H−H′)
			Probability a random tree is between H and H′=Bin Density⋅(H−H′)

		PDF is continuous function that defines the likelihood of an arbitrary range of values - p(r) - linear func
			r = 0 -> p(r) = 0
			r = 2 -> p(r) = 2
			PDF - probability func
			area(p(r),0,2)=1
			p(r) = C⋅r
			C = 1/2
			p(r)=r/2
			Probability(r|x−Δx<r<x+Δx)=area(p(r),x−Δx,x+Δx)=P(x+Δx)−P(x−Δx)
		10.0 * random_double() - [0,10]
		p(r)=r2 - [1.8,2.0] - greater probability	-> fix - double f(double d) (in vec3.h)
		Solve halfway:	- computational expensive - O(n^2)
			1. Solve for halfway point of a PDF
			2. Recurse into lower half, repeat step 1
			3. Recurse into upper half, repeat step 1
		Metropolis-Hastings Algorithm - better version - O(nlogn)
		
		Approximating Distributions:
			f(x)=e^(−x/2π)*sin2(x)
			P(x)=area(p(x′),−∞,x)
			ICD(d)=sqrt(4⋅random_double())
			nonuniformity -> inaccurately brigh image
			fix -> down-weight where we sample more frequently, and to up-weight where we sample less frequently

			unform PDF - converge slower
			linear PDF - converge faster
			nonuniform PDF - importance sampling

		Monte Carlo Ray Tracer review:
			1, You have an integral of f(x) over some domain [a,b]
			2. You pick a PDF p that is non-zero and non-negative over [a,b]	
			3. You average a whole ton of f(r)p(r) where r is a random number with PDF p

	Any choice of PDF p  always converge to the right answer
	The closer that p approximates f, the faster  it converges

Monte Carlo - Sphere of Directions
	the rejection method: random direction - random vector and rejcting it if outside of the sphere - repeat (book 1 and 2)
	the inversion method: invert PDF
		random point, mapping the unit sphere to Cartesian coordinates
		f(θ,ϕ)=cos^2(θ)
		PDF represents the relative probability of that direction - random_unit_vector()
		f(θ,ϕ)=cos^2(θ)=dz^2	- θ angle with z-axis
		4/3π=4.188790204786391

Light Scattering
	A - Albedo - form of fractional reflectance
	probability of light beeing scattered: A
	probability of light beeing absorbed: 1-A
	energy wave length - E=hc/λ
	
	Scattering:
		scattering PDF: pScatter()
		incident direction:  pScatter(ωi,ωo)
		mirror-like surface as viewing angle (incident angle) approaches grazing
		x - math notation for the scattering position: x=(x,y,z)
		The albedo of an object can also depend on the quantities: A(x,ωi,ωo,λ)
		Coloro(x,ωo,λ)=∫ωiA(x,ωi,ωo,λ)⋅pScatter(x,ωi,ωo,λ)⋅Colori(x,ωi,λ)	- recursive algorithm (ray_color.h)
	The Scattering PDF:
		Coloro(x,ωo,λ)≈(∑A(…)⋅pScatter(…)⋅Colori(…)) / p(x,ωi,ωo,λ)
		p(x,ωi,ωo,λ) - PDF of outgoing randomly generateed direction
		pScatter(…) of a Lambertian surface is proportional to  cos(θo)

		pScatter(x,ωi,ωo,λ)=C⋅cos(θo)
		1=∫2πϕ=0∫π2θ=0C⋅cos(θ)dA
		C=1π
		Coloro(x,ωo,λ)≈∑A(…)⋅Colori(…) ->(turn attenuation * ray_color(scattered, depth-1, world);   //in ray_color()

		Bidirectional Reflectance Distribution Function (BRDF):
			BRDF(ωi,ωo,λ)=(A(x,ωi,ωo,λ)⋅pScatter(x,ωi,ωo,λ)) / cos(θo)
			(for a Lambertian surface) -> BRDF=A/π -> scattering albedo

Importance Sampling
	Goal - reduce noise
	extra rays toward light sources -> less noisy picture
	PDF pLight(ωo)
	p(ωo)=12pSurface(ωo)+12pLight(ωo)
	all PDFs eventually converge to the correct answer
	Larger PDF where the product pScatter(x,ωi,ωo)⋅Colori(x,ωi) is largest --> Largest Colori(x,ωi)

Generating Random Directions
	Random Directions Relative to the Z Axis
		inversion method: 
			θ - angle from the normal
			 p(ω)=f(θ) - distibution simetric around z-axis
			 a(ϕ)=12π
			 b(θ)=2πf(θ)sin(θ)
			 ϕ=2π⋅r1
			 r2=∫θ0 b(θ′)dθ′
			 cos(θ)=1−2r2

		Uniform Sampling a Hemisphere
			 f()/p()=cos3(θ)/12π

Orthonormal Bases
	Generalization of normals, instead of all aligned with z axis
	Orthonormal basis (ONB) - three mutually orthogonal unit vectors
	The camera and objects must be described in the same coordinate system
	O - origin of the scene, x,y,z - Cartesian co (3,-2,7):
		Location is O+3x−2y+7z
	measure coordinates: 
		O′ & (u,v,w) -> Location is O′+uu+vv+ww

	Generating an Orthonormal Basis:
		surface normal vector n
		vector a that is of nonzero length and nonparallel with n
		vectors s and t perpendicular to n
			s=unit_vector(n×a)
			t=n×s

Sampling Lights Directly
	PDF, p(ω) - light ray direction
	A - surface area, PDF on the surface = 1/A
	small area dω -> dω=dA⋅cos(θ) / distance2(p,q) -> p(ω)=distance2(p,q) / cos(θ)⋅A
	noisy - light  two-sided and there is a small space between light and ceiling
		fix -> emit light in only one direction

Mixture Densities
	PDF Class:
		1/4π
		1/2π
		cos(θ)/π
		Should:
		1. returning a random direction weighted by the internal PDF distribution
		2. returning the corresponding PDF distribution value in that direction

	Mixture PDF Class:
			inear mixtures of any PDFs:
			pMixture()=w0p0()+w1p1()+w2p2()+…+wn−1pn−1()
			1=w0+w1+w2+…+wn−1
			Average: pMixture(ωo)=12pSurface(ωo)+12pLight(ωo)
PDF Clean up:
	ray_color() (2 PDFs):
		1. p0() related to the shape of the light
		2. p1() related to the normal vector and type of surface

	Diffuse Versus Specular:
		one material - two differnet rays (ex. wood, specular+diffuse)

